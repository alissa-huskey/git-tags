#!/usr/bin/env python

"""Script to generate manpage"""

import argparse
from copy import deepcopy
from pathlib import Path
from subprocess import run
from os import _exit as exit
import sys
from pprint import pprint

from poetry.core.pyproject.toml import PyProjectTOML
from more_itertools import first, first_true, flatten, last
from build_manpages.cli import ap as base_parser

def abort(message):
    """Print error message and exit"""
    print(message, file=sys.stderr)
    exit(1)

class Config():
    """Class for poetry config"""
    ROOTDIR = Path(__file__).parent.parent
    _poetry = None
    _url = None

    """Used to store tool.poetry section of pyproject.toml """
    poetry = {}

    def __init__(self):
        """Load pyproject.toml"""
        self.toml = PyProjectTOML( self.ROOTDIR / "pyproject.toml")
        self.poetry = self.get("tool", "poetry", default={})

        if not self.toml.is_poetry_project():
            abort(f"Not a poetry project: {self.ROOTDIR}")

    @property
    def urls(self):
        """List of all possible urls"""
        return [self.poetry.get(key) for key in ("homepage", "repository", "documentation")]

    @property
    def url(self):
        """Return the first stored url or first not null url"""
        if self._url:
            return self._url

        return first_true(self.urls)

    def __getattr__(self, attr):
        """Enable object.name access for attributes in tool.poetry section"""
        try:
            return self.__dict__["poetry"][attr]
        except KeyError:
            return self.__getattribute__(attr)

    def get(self, *keys, data=NotImplemented, default=None):
        """Return value from config

        Arguments
        ---------
        * *keys             : list of keys
        * default (optional): default to return if no value
        * data              : used internally for recursion

        Example
        -------
        >>> cfg = Config()
        >>> cfg.get("tool", "poetry", "license")
        MIT
        >>> cfg.get("tool", "poetry", "readme", default="README.md")
        README.md
        >>> cfg.get("tool", "poetry", "readme")
        """

        if data is NotImplemented:
            data = deepcopy(self.toml.data)

        keys = list(keys)
        key = keys.pop(0)

        if not isinstance(data, dict):
            abort(f"not a dict: {data}")

        if keys:
            return self.get(*keys, data=data.get(key, {}), default=default)
        else:
            return data.get(key, default)


class Command():
    """Class for constructing argparse-manpage command"""

    program = "argparse-manpage"

    """Used to store Config object"""
    cfg = None

    """Used to store command line options"""
    options = {}

    """Mapping of argparse.dest to argparse.name"""
    option_names = {}

    def __init__(self, **kwargs):
        """Initialize argparse parser

        Keyword Arguments
        -----------------
        * config (Config):
        * kwargs: options to add

        """

        # initialize Config object
        self.cfg = kwargs.pop("config", Config())

        # initialize option_names dict
        self.option_names = {}

        # initialize Argument Parser
        base_parser.add_help = False
        self.parser = argparse.ArgumentParser(
            description="Generate man page.",
            parents=[base_parser],
            conflict_handler="resolve",
        )
        default_group = first(sorted(
            self.parser._action_groups,
            key=lambda x: len(x._group_actions),
            reverse=True
        ))
        default_group.title = "argparse-manpage options"

        # remove help from argparse-manpage group
        help_arg = default_group._group_actions.pop(0)

        internal = self.parser.add_argument_group("mkman options")
        internal._group_actions.insert(0, help_arg)
        internal.add_argument(
            "-V",
            "--verbose",
            action="store_true",
            help="print git command"
        )

        # add all kwargs to self.options
        self.options = {}
        for key, value in kwargs.items():
            self.add(key, value)

        # generate option_names mapping for use in self.parse()
        for action in self.parser._actions:
            names = sorted(action.option_strings, key=len, reverse=True)
            if action in internal._group_actions:
                continue
            self.option_names[action.dest] = first(names).lstrip("-")

        self.add("output", f"{self.cfg.name}.1", override=False)

    def add(self, name, value, override=True):
        """Add option

        Arguments
        ---------
        * name (str)         : option name
        * value (str)        : option value
        * override (bool)    : override if option already exists (default: True)
        """
        if not value:
            return

        if (not override) and (name in self.options):
            return

        self.options[name.replace("_", "-")] = value

    def parse(self):
        """Add results of argparse.parse() to self.options"""
        self.values = self.parser.parse_args(self.args + sys.argv[1:])
        for name, value in vars(self.values).items():
            # strip internal options
            if name not in self.option_names:
                continue
            self.add(self.option_names[name], value)
        return self.values

    @property
    def command(self):
        """List containing command and arguments to be passed to subprocess.run"""
        return [self.program] + self.args

    @property
    def args(self):
        """List of --key [value] style arguments for the command line"""
        opts = [ (f"--{k}", v) for k,v in self.options.items() ]
        return list(flatten(opts))

    def __str__(self):
        """Command that can be pasted on the command line"""
        return " ".join(self.command)

    def run(self):
        """Execute on the shell via subprocess.run"""
        result = run(self.command)
        if result.returncode:
            exit(result.returncode)
        return result

def main():
    """Construct and execute argparse-manpage command"""

    cfg = Config()

    cmd = Command(
        pyfile=cfg.name,
        author=first(cfg.get("tool", "poetry", "authors")),
        project_name=cfg.name,
        url=cfg.url,
        config=cfg,
        function="parser",
    )


    cmd.parse()

    if cmd.values.verbose:
        print(">", cmd, "\n", file=sys.stderr)

    cmd.run()

    print(f"Generated manpage at: {cmd.values.outfile}")

if __name__ == "__main__":
    main()
